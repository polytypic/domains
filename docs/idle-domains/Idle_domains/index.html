<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Idle_domains (idle-domains.Idle_domains)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">idle-domains</a> &#x00BB; Idle_domains</nav><header class="odoc-preamble"><h1>Module <code><span>Idle_domains</span></code></h1><p>This is a framework for co-operative allocation of domains particularly intended for libraries providing schedulers for parallel programming.</p><p>The overall goal is to make it possible for asynchronous and parallel programming libraries to co-exist and co-operate profitably with minimal loss of performance so that applications do not have to unnecessarily choose between competing library ecosystems.</p><p>The basic problem with domains in OCaml is that they are very expensive. They are relatively expensive to create and, more importantly, <a href="https://github.com/ocaml-multicore/domainslib/issues/77#issuecomment-1290398870">performance drops when there are more domains than available hardware threads</a>. Even if the cost of idle domains might be reduced via future runtime optimizations, having <a href="https://github.com/ocaml-multicore/domainslib/issues/92#issuecomment-1291671479">at most one domain per available hardware thread</a> can provide performance benefits.</p><p>This basically means that libraries that want to co-exist and co-operate should never create domains on their own.</p><p>On the other hand, what (low-level) asynchronous and parallel programming libraries want to do is to schedule work (i.e. tasks, fibers, ...) on one or more domains. A scheduler typically runs a loop on one or more domains that takes work from some sort of dispenser (queue, stack, work-stealing deque, ...). The exact details of how a scheduler is implemented tend to be very important.</p><p>This framework manages a number of domains and keeps track of when a domain is idle. Co-operative libraries can then attempt to allocate idle domains for running their schedulers.</p><p>On the other hand, this framework is not intended to be a general purpose scheduler and does not make use of any unbounded dispensers. This framework merely manages the allocation of a finite number of domains. The goal is to provide a layer on top of which effective and efficient scheduler libraries can be written.</p><p>The implementation of this framework is lock-free with the exception that each domain has a mutex and a condition variable that are used by the domain to wait for a signal to wake up. This means that either domain involved in a specific wake-up operation may be blocked.</p></header><nav class="odoc-toc"><ul><li><a href="#library-level-interface">Library level interface</a><ul><li><a href="#reflecting-managed-domains">Reflecting managed domains</a></li><li><a href="#idling">Idling</a></li><li><a href="#schedulers">Schedulers</a><ul><li><a href="#spawning-schedulers">Spawning schedulers</a></li></ul></li></ul></li><li><a href="#application-level-interface">Application level interface</a></li><li><a href="#exceptions">Exceptions</a></li></ul></nav><div class="odoc-content"><h2 id="library-level-interface"><a href="#library-level-interface" class="anchor"></a>Library level interface</h2><p>The operations in this section are intended for writing libraries that use domains co-operatively.</p><div class="odoc-spec"><div class="spec type anchored" id="type-managed_id"><a href="#type-managed_id" class="anchor"></a><code><span><span class="keyword">type</span> managed_id</span><span> = <span class="keyword">private</span> <span class="xref-unresolved">Stdlib</span>.Domain.id</span></code></div><div class="spec-doc"><p>A <a href="#type-managed_id"><code>managed_id</code></a> is an alias for <code>Domain.id</code> used to indicate the subset of ids referring to managed domains.</p></div></div><h3 id="reflecting-managed-domains"><a href="#reflecting-managed-domains" class="anchor"></a>Reflecting managed domains</h3><div class="odoc-spec"><div class="spec value anchored" id="val-all"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-managed_id">managed_id</a> list</span></span></code></div><div class="spec-doc"><p>Returns a list of all the managed domains. This list also includes the main domain as the first element.</p><p>The intended use case of <a href="#val-all"><code>all</code></a> is for libraries providing <a href="#type-scheduler"><code>scheduler</code></a>s to perform per domain preparation once.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-self"><a href="#val-self" class="anchor"></a><code><span><span class="keyword">val</span> self : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-managed_id">managed_id</a></span></code></div><div class="spec-doc"><p>An alias for <code>Domain.self ()</code> that asserts that is called from a managed domain. The main domain is considered to be a managed domain.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-next"><a href="#val-next" class="anchor"></a><code><span><span class="keyword">val</span> next : <span><a href="#type-managed_id">managed_id</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-managed_id">managed_id</a></span></code></div><div class="spec-doc"><p>Returns the next sibling of the given managed domain. The siblings form a cycle and the main domain is included in the cycle.</p><p>An intended use case for <a href="#val-next"><code>next</code></a> is to iterate over managed domains e.g. to implement work-stealing.</p></div></div><h3 id="idling"><a href="#idling" class="anchor"></a>Idling</h3><div class="odoc-spec"><div class="spec value anchored" id="val-wakeup"><a href="#val-wakeup" class="anchor"></a><code><span><span class="keyword">val</span> wakeup : <span><a href="#type-managed_id">managed_id</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Ensures that the specified managed domain is woken up. This is for use with <a href="#val-idle"><code>idle</code></a> to ensure that the predicate given to <a href="#val-idle"><code>idle</code></a> is checked and <a href="#val-idle"><code>idle</code></a> may return.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-idle"><a href="#val-idle" class="anchor"></a><code><span><span class="keyword">val</span> idle : <span>until:<span>(<span><span class="type-var">'ready</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'ready</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Runs the current domain in a managed fashion <code>until</code> the given predicate returns <code>true</code>. The caller must arrange for <a href="#val-wakeup"><code>wakeup</code></a> to be called to ensure that the predicate is checked to allow <a href="#val-idle"><code>idle</code></a> to return.</p><p>The <code>until</code> predicate should ideally be as fast as possible, because it is called repeatedly and it is also called during the period when the mutex of the domain is locked before waiting on the condition variable of the domain for a signal to wake up.</p><p>During the <a href="#val-idle"><code>idle</code></a> call any <a href="#type-scheduler"><code>scheduler</code></a>s may be spawned to run on the domain.</p></div></div><h3 id="schedulers"><a href="#schedulers" class="anchor"></a>Schedulers</h3><div class="odoc-spec"><div class="spec type anchored" id="type-scheduler"><a href="#type-scheduler" class="anchor"></a><code><span><span class="keyword">type</span> scheduler</span><span> = <span><a href="#type-managed_id">managed_id</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>A <a href="#type-scheduler"><code>scheduler</code></a> is just a function that executes on a specific domain.</p><p>Once a <a href="#type-scheduler"><code>scheduler</code></a> is called, it owns the domain for as long as it runs. For co-operative use of domains, the <a href="#type-scheduler"><code>scheduler</code></a> should return as soon as it no longer has work to do.</p><p>All <a href="#type-scheduler"><code>scheduler</code></a>s must stop before the program can exit. If a scheduler has no better way to decide when to stop, it should periodically call <a href="#val-check_terminate"><code>check_terminate</code></a>.</p><p>A <a href="#type-scheduler"><code>scheduler</code></a> should never <code>raise</code> arbitrary exceptions as there is no effective mechanism to handle such exceptions promptly, see <a href="#val-prepare"><code>prepare</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_terminate"><a href="#val-check_terminate" class="anchor"></a><code><span><span class="keyword">val</span> check_terminate : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Checks whether the program is being terminated and, if so, raises the <a href="#exception-Terminate"><code>Terminate</code></a> exception.</p><p>The implementation of <a href="#val-check_terminate"><code>check_terminate</code></a> has been carefully optimized to make sure that it can be called highly frequently.</p><p>It is typically not necessary to call <a href="#val-check_terminate"><code>check_terminate</code></a> from a <a href="#type-scheduler"><code>scheduler</code></a> that always returns as soon as it has no work to do.</p></div></div><h4 id="spawning-schedulers"><a href="#spawning-schedulers" class="anchor"></a>Spawning schedulers</h4><div class="odoc-spec"><div class="spec value anchored" id="val-try_spawn"><a href="#val-try_spawn" class="anchor"></a><code><span><span class="keyword">val</span> try_spawn : <span>scheduler:<a href="#type-scheduler">scheduler</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Tries to spawn the given <a href="#type-scheduler"><code>scheduler</code></a> to run on a managed domain that happens to be idle at the moment. Returns <code>true</code> on success and <code>false</code> on failure.</p><p>The implementation of <a href="#val-try_spawn"><code>try_spawn</code></a> has been carefully optimized to make sure that it can be called highly frequently. No unbounded queues or other kinds of dispensers are maintained by this library. If there is contention or it seems that there are no idle domains at the moment, <a href="#val-try_spawn"><code>try_spawn</code></a> will immediately return <code>false</code>.</p><p>The intention is not that <a href="#val-try_spawn"><code>try_spawn</code></a> would be called in a loop until it returns <code>true</code>. The intention is that libraries may call <a href="#val-try_spawn"><code>try_spawn</code></a> every time they believe there is potentially work for an additional <a href="#type-scheduler"><code>scheduler</code></a>.</p><p>For best performance the caller likely wants to make sure that no closure needs to be allocated for the <a href="#type-scheduler"><code>scheduler</code></a>.</p></div></div><h2 id="application-level-interface"><a href="#application-level-interface" class="anchor"></a>Application level interface</h2><p>Applications should explicitly decide how the operations in this section are called and libraries should never call these functions on their own.</p><div class="odoc-spec"><div class="spec value anchored" id="val-prepare"><a href="#val-prepare" class="anchor"></a><code><span><span class="keyword">val</span> prepare : <span>num_domains:int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Prepares the given number of managed domains, including the calling main domain, for use. The number of managed domains is restricted to the range <code>(1, Domain.recommended_domain_count ())</code>.</p><p><a href="#val-prepare"><code>prepare</code></a> is idempotent and should be called at most once during application start-up.</p><p><a href="#val-prepare"><code>prepare</code></a> registers an <code>at_exit</code> operation to terminate all the managed domains. The termination process <code>Domain.join</code>s with all the managed domains. Unexpected exceptions are collected into a list and a single <a href="#exception-Managed_domains_raised"><code>Managed_domains_raised</code></a> exception is raised in case the list is non-empty.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prepare_opt"><a href="#val-prepare_opt" class="anchor"></a><code><span><span class="keyword">val</span> prepare_opt : <span>num_domains:<span>int option</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Calls <a href="#val-prepare"><code>prepare</code></a> defaulting to <code>Domain.recommended_domain_count ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prepare_recommended"><a href="#val-prepare_recommended" class="anchor"></a><code><span><span class="keyword">val</span> prepare_recommended : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Calls <a href="#val-prepare"><code>prepare</code></a> with <code>Domain.recommended_domain_count ()</code>.</p></div></div><h2 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h2><p>Users of this framework should never need to <code>raise</code> any of the exceptions in this section.</p><div class="odoc-spec"><div class="spec exception anchored" id="exception-Managed_domains_raised"><a href="#exception-Managed_domains_raised" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Managed_domains_raised</span> <span class="keyword">of</span> <span>exn list</span></span></code></div><div class="spec-doc"><p>Raised during application termination in case any <code>Domain.join</code>s with the managed domains raise exceptions due to <a href="#type-scheduler"><code>scheduler</code></a>s passed to <a href="#val-try_spawn"><code>try_spawn</code></a> having raised exceptions.</p><p>This exception indicates that some <a href="#type-scheduler"><code>scheduler</code></a> has a bug.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Terminate"><a href="#exception-Terminate" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Terminate</span></span></code></div><div class="spec-doc"><p>Exception used to indicate expected termination of a domain, see <a href="#val-check_terminate"><code>check_terminate</code></a>.</p></div></div></div></body></html>